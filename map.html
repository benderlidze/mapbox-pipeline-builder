<!DOCTYPE html>
<html>

<head>
    <title>Petro Ninja Pipeline Builder</title>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link rel="stylesheet" href="https://uicdn.toast.com/tui.pagination/latest/tui-pagination.css" />
    <script src="https://uicdn.toast.com/tui.pagination/latest/tui-pagination.js"></script>
    <script src="https://d3js.org/d3.v6.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>

    <script src="js/xlsx.full.min.js"></script>
    <script src="https://unpkg.com/shpjs@latest/dist/shp.js"></script>
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.1.0/mapbox-gl.js"></script>
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.1.0/mapbox-gl.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.3.0/turf.min.js"></script>

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/toastify-js/src/toastify.min.css" />
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/toastify-js"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />

    <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.2.0/mapbox-gl-draw.js"></script>
    <link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.2.0/mapbox-gl-draw.css"
        type="text/css" />

    <script src="js/shortcut.js"></script>
    <link rel="stylesheet" href="css/main.css" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/wicket/1.3.6/wicket.min.js"
        integrity="sha512-7V9RlkyO655oDrkJ7kMXAa4Z+DS0+Kq/eXV0ZKWAv9RJtstw7rHJU1/KgpLovGZtL2FaJ9L24w3qa6L/qy3spg=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>

<body class="container">
    <!-- The Modal -->
    <div id="myModal" class="modal">
        <!-- Modal content -->
        <div class="modal-content">
            <div class="modal-header">
                <span class="close">&times;</span>
                <h2>Action required</h2>
            </div>
            <div class="modal-body">
                <div><input type="text" id="score" placeholder="Score" /></div>
                <div><input type="text" id="note" placeholder="Note" /></div>
            </div>
            <div class="modal-footer">
                <button id="save" class="button blue">Save</button>
                <button id="cancel" class="button blue">Cancel</button>


            </div>
        </div>
    </div>

    <div class="left">
        <nav id="menu">
            <!-- <a href="#" id="clearLineFilter" class="active">Clear filters</a> -->
        </nav>
        <div id="lineinfo"></div>
        <div id="map"></div>
    </div>
    <div class="right">
        <div style="display: none;">
            <div id="allpipes"></div>
            <div id="">
                <select id="groups"></select>
                <select id="projects" style="display: none"></select>
            </div>
            <div style="display: flex">
                <div>
                    <label class="switch">
                        <input type="checkbox" id="incomplete" />
                        <div class="slider round"></div>
                    </label>
                </div>
                <div style="position: relative; right: -155px">
                    <label class="switch">
                        <input type="checkbox" id="corridors" />
                        <div class="slider second-slider round"></div>
                    </label>
                </div>
            </div>
            <div>
                <input type="search" id="inputFilter" placeholder="filter" />
            </div>
            <div id="paginator">
                <div id="pagination1" class="tui-pagination"></div>
            </div>
        </div>
        <div id="list"></div>

        <div style="text-align: center; display: none;">
            <button id="next" class="button">Next project &rarr;</button>
        </div>
    </div>
</body>

<script>
    //const apiUrl = "https://petro-ninja-pipeline-builder.herokuapp.com/api/api_v2.php";
    const apiUrl = 'https://serg.one/mapbox-pipeline/api/api_v3.php';
    var pressedKeys = {};
    window.onkeyup = function (e) {
        pressedKeys[e.keyCode] = false;
    };
    window.onkeydown = function (e) {
        pressedKeys[e.keyCode] = true;
    };

    const filters = {
        number: 0,
        segment: 0,
        project: 0,
    };

    const currentPage = [];
    let selectedId = 0;
    let listJson = {};
    let arrayData = [];
    let pagination;
    let allPipes = [];

    const options = {
        totalItems: 0,
        itemsPerPage: 50,
        visiblePages: 5,
        centerAlign: true,
    };
    const allpipesDiv = document.getElementById("allpipes");
    const nextProjectButton = document.getElementById("next");
    const groupsInput = document.getElementById("groups");
    const projectsInput = document.getElementById("projects");
    const lineinfo = document.getElementById("lineinfo");
    const clearLineFilter = document.getElementById("clearLineFilter");
    const list = document.getElementById("list");
    const inputFilter = document.getElementById("inputFilter");
    const incompleteFilter = document.getElementById("incomplete");
    const corridorsFilter = document.getElementById("corridors");

    mapboxgl.accessToken =
        "pk.eyJ1Ijoic2JpbHN0b24iLCJhIjoiY2trcHpweW80MDRwcTJ3cnZ2bXZmejA2bSJ9.vf8ohNEOskgF0ERmQ4Y1kQ";
    var map = new mapboxgl.Map({
        container: "map",
        style: "mapbox://styles/sbilston/ckky3y0y20uev17nzhmcafr8p",
        center: { lng: -126.0546135006228, lat: 55.0372830480068 },
        zoom: 5.36,
    });

    map.dragRotate.disable();

    //===============================CUSTOM DRAW MODE===========================
    //===============================CUSTOM DRAW MODE===========================
    //===============================CUSTOM DRAW MODE===========================
    // const tooltip = new mapboxgl.Popup({
    //     closeButton: true,
    //     closeOnClick: false,
    //     offset: [0, -10]
    // });
    function createVertex(parentId, coordinates, path, selected) {
        return {
            type: "Feature",
            properties: {
                meta: "vertex",
                parent: parentId,
                coord_path: path,
                active: selected ? true : false,
            },
            geometry: {
                type: "Point",
                coordinates: coordinates,
            },
        };
    }



    MapboxDraw.modes.direct_select.onDrag = function (state, e) {
        if (state.canDragMove !== true) return;
        state.dragMoving = true;
        e.originalEvent.stopPropagation();
        const delta = {
            lng: e.lngLat.lng - state.dragMoveLocation.lng,
            lat: e.lngLat.lat - state.dragMoveLocation.lat,
        };
        if (state.selectedCoordPaths.length > 0) this.dragVertex(state, e, delta);
        else this.dragFeature(state, e, delta);
        state.dragMoveLocation = e.lngLat;

        // console.log('state.feature', state.feature);
        if (state.feature.type === "LineString") {
            const length = turf.length(state.feature, { units: "meters" }).toFixed(3);
            if (lineinfo) {

                const sq = arrayData.find(i => i['Pipeline ID'] === selectedId);
                const pipeLength = (+sq['Length (km)'] * 1000);
                let expectedDistance = currentPipeline ? currentPipeline.expectedLength + "m" : pipeLength + "m";

                lineinfo.style.display = "inline";
                lineinfo.innerHTML = `Total distance ${length}m`;
                lineinfo.innerHTML = `Total distance: ${length}m / ${expectedDistance}`;
            }
        }
    };

    function isEventAtCoordinates(event, coordinates) {
        if (!event.lngLat) return false;
        return event.lngLat.lng === coordinates[0] && event.lngLat.lat === coordinates[1];
    }


    MapboxDraw.modes.draw_line_string.clickAnywhere = function (state, e) {
        if (e.originalEvent.shiftKey) {
            const line = state.line.coordinates;
            const lastClick = line[line.length - 1]
            const a = map.project(lastClick)
            const res = line.map((i, index) => {
                const b = map.project(i)
                const d = distance(a, b)
                return {
                    index,
                    distance: d
                };
            }).find(i => i.distance < 8 && i.distance > 0)
            if (res) {
                state.line.removeCoordinate(res.index)
                state.currentVertexPosition = state.currentVertexPosition - 1
            }

        } else {
            if (state.currentVertexPosition > 0 && isEventAtCoordinates(e, state.line.coordinates[state.currentVertexPosition - 1]) ||
                state.direction === 'backwards' && isEventAtCoordinates(e, state.line.coordinates[state.currentVertexPosition + 1])) {
                return this.changeMode('simple_select', { featureIds: [state.line.id] });
            }
            this.updateUIClasses({ mouse: 'add' });
            state.line.updateCoordinate(state.currentVertexPosition, e.lngLat.lng, e.lngLat.lat);
            if (state.direction === 'forward') {
                state.currentVertexPosition++;
                state.line.updateCoordinate(state.currentVertexPosition, e.lngLat.lng, e.lngLat.lat);
            } else {
                state.line.addCoordinate(0, e.lngLat.lng, e.lngLat.lat);
            }
        }

    };

    function distance(a, b) {
        var dist = Math.sqrt(Math.pow((a.x - b.x), 2) + Math.pow((a.y - b.y), 2));
        return dist;
    }

    MapboxDraw.modes.draw_line_string.clickOnVertex = function (state, event) {

        if (event.originalEvent.button === 2) return; //it is right click, do not delete points

        const line = state.line.coordinates;
        const lastClick = line[line.length - 1]
        const a = map.project(lastClick)
        const res = line.map((i, index) => {
            const b = map.project(i)
            const d = distance(a, b)
            return {
                index,
                distance: d
            };
        }).find(i => i.distance < 8 && i.distance > 0)
        if (res) {
            state.line.removeCoordinate(res.index)
            state.currentVertexPosition = state.currentVertexPosition - 1
        }
        //return this.changeMode('simple_select', { featureIds: [state.line.id] });
    };

    MapboxDraw.modes.draw_line_string.toDisplayFeatures = function (state, geojson, display) {
        const isActiveLine = geojson.properties.id === state.line.id;
        geojson.properties.active = isActiveLine ? "true" : "false";
        if (!isActiveLine) return display(geojson);

        // Only render the line if it has at least one real coordinate
        if (geojson.geometry.coordinates.length < 2) return;
        geojson.properties.meta = "feature";
        const vertex = createVertex(
            state.line.id,
            geojson.geometry.coordinates[
            state.direction === "forward" ? geojson.geometry.coordinates.length - 2 : 1
            ],
            `${state.direction === "forward" ? geojson.geometry.coordinates.length - 2 : 1}`,
            false
        );
        const point = geojson.geometry.coordinates[geojson.geometry.coordinates.length - 1];
        const length = turf.length(geojson, { units: "meters" }).toFixed(3);

        if (lineinfo) {

            const sq = arrayData.find(i => i['Pipeline ID'] === selectedId);
            const pipeLength = (+sq['Length (km)'] * 1000);

            let expectedDistance = currentPipeline ? currentPipeline.expectedLength + "m" : pipeLength + "m";
            lineinfo.style.display = "inline";
            lineinfo.innerHTML = `Total distance: ${length}m / ${expectedDistance}`;
        }

        //show all points on the line
        const temp = [...geojson.geometry.coordinates]
        temp.splice(-1, 1)
        temp.map((i, index) => {
            const g = {
                type: "Feature",
                properties: {
                    meta: "vertex",
                    parent: state.line.id,
                },
                geometry: {
                    type: "Point",
                    coordinates: i,
                }
            }
            display(g)
        })
        //display(vertex);
        display(geojson);
    };

    //===============================CUSTOM DRAW MODE===========================
    //===============================CUSTOM DRAW MODE===========================
    //===============================CUSTOM DRAW MODE===========================

    var Draw = new MapboxDraw({
        displayControlsDefault: false,
        controls: {
            line_string: true,
            trash: true,
        },
    });

    map.addControl(Draw, "top-right");

    map.on("load", function () {

        fetch("data/pipeline_geometry_no_functions.xlsx")
            .then(function (res) {
                if (!res.ok) throw new Error("fetch failed");
                return res.arrayBuffer();
            })
            .then(function (ab) {
                var data = new Uint8Array(ab);
                var wb = XLSX.read(data, { type: "array" });


                var first_sheet_name = wb.SheetNames[0];
                var worksheet = wb.Sheets[first_sheet_name];
                arrayData = XLSX.utils.sheet_to_json(worksheet, { raw: true });

                console.log('arrayData', arrayData);

                let table = '<table class="lines">';
                arrayData.forEach((i, key) => {

                    const id = `${i["Pipeline ID"]}`;

                    table += `<tr class="line" id="pipe_${id}" key="${key}">
                        <td class="gotPipe" id="green_${id}"></td>
                        <td class="pipe" lineid="${id}"                            >
                            <div> <b>${i["Pipeline ID"]} | ${i["Field"]}</b></div>
                            <div><b>From:</b> ${i["Raw From"]} <br><b>To:</b>${i["Raw To"]}</div>
                            <div><b>Length: ${+i["Length (km)"] * 1000}m</b></div>
                            <div><b>Diameter</b>: ${i["Diameter"]}mm</div>
                        </td>
                        <td>
                            <button class="btn saveData" id="b_${id}" onclick="saveData(${i["Project #"]}, ${i["Segment #"]})" style="visibility:hidden;"><i class="fa fa-save"></i></button>
                        </td>
                    </tr>
                `;
                });
                table += "</table>";
                list.innerHTML = table;

                calcColors()
            });

        //START===========isTiledInMapox=======================

        // getIsTiledInMapbox();


        map.addSource("isTiledInMapox", {
            type: "geojson",
            data: {
                type: "FeatureCollection",
                features: [],
            },
        });
        map.addLayer({
            id: "isTiledInMapox",
            type: "line",
            source: "isTiledInMapox",
            layout: {
                "line-join": "round",
                "line-cap": "round",
            },
            paint: {
                "line-color": "black",
                "line-width": 3,
            },
        });
        //END===========isTiledInMapox=======================

        map.addSource("squares", {
            type: "geojson",
            data: {
                type: "FeatureCollection",
                features: [],
            },
        });

        map.addLayer({
            id: "squares",
            type: "line",
            source: "squares",
            layout: {
                "line-join": "round",
                "line-cap": "round",
            },
            paint: {
                "line-color": "red",
                "line-width": 1,
            },
        });

        //when group and project selected - display current project geometry
        map.addSource("projectGeometry", {
            type: "geojson",
            data: {
                type: "FeatureCollection",
                features: [],
            },
        });
        map.addLayer(
            {
                id: "projectGeometry",
                type: "line",
                source: "projectGeometry",
                layout: {
                    "line-join": "round",
                    "line-cap": "round",
                },
                paint: {
                    "line-color": "red",
                    "line-width": 5,
                    "line-opacity": 0.3,
                },
            },
            "gl-draw-line-inactive.cold"
        );
        //}, ["gl-draw-line-inactive.cold", "gl-draw-line-active.cold", "gl-draw-line-static.cold", "gl-draw-line-inactive.hot", "gl-draw-line-active.hot", "gl-draw-line-static.hot"]);

        map.addSource("route", {
            //mapbox source for geojson data
            type: "geojson",
            data: {
                type: "FeatureCollection",
                features: [],
            },
        });

        map.addLayer({
            id: "linefill",
            type: "fill",
            source: "route",
            layout: {},
            paint: {
                "fill-color": "#088",
                "fill-opacity": 0.1,
            },
        });

        map.addLayer({
            id: "route",
            type: "line",
            source: "route",
            layout: {
                "line-join": "round",
                "line-cap": "round",
            },
            paint: {
                "line-color": ["get", "color"],
                "line-width": 5,
            },
        });

        // Create a popup, but don't add it to the map yet.
        var popup = new mapboxgl.Popup({
            closeButton: true,
            closeOnClick: false,
        });

        map.on("click", "linefill", function (e) {
            if (Draw.getMode() === "draw_line_string") {
                //disable info when drawing
                return;
            }
            // Change the cursor style as a UI indicator.
            var coordinates = e.lngLat;
            var props = e.features[0].properties;
            console.log("props", props);
            const descr = `
            PROJECT_NU:${props.PROJECT_NU}
            <br>
            PROPONENT:${props.PROPONENT}
            <br>
            <button class="filter" project="${props.PROJECT_NU}">Filter by ${props.PROJECT_NU}</button>
            `;
            popup.setLngLat(coordinates).setHTML(descr).addTo(map);
        });
        map.on("mouseenter", "linefill", function (e) {
            if (Draw.getMode() === "draw_line_string") {
                //disable info when drawing
                return;
            }
            // Change the cursor style as a UI indicator.
            map.getCanvas().style.cursor = "pointer";
        });

        map.on("mouseleave", "linefill", function () {
            map.getCanvas().style.cursor = "";
            // popup.remove();
        });

        map.on("contextmenu", () => {
            console.log("right click");
            saveData();
        });

        map.on("click", (e) => {
            if (e.originalEvent.ctrlKey) {
                console.log("Draw mode");
                Draw.changeMode(Draw.modes.DRAW_LINE_STRING);
            }
        });

        map.on("draw.delete", updateLineInfoBox);
        function updateLineInfoBox() {
            lineinfo.innerHTML = "";
            lineinfo.style.display = "none";
        }


    });

    function getIsTiledInMapbox() {
        console.log('getIsTiledInMapbox');
        fetch(apiUrl + '?isTiledInMapbox=false')
            .then(data => data.json())
            .then((json) => {
                const projectGeometry = [];
                json.forEach((i) => {
                    const c = JSON.parse(i.geometry);
                    if (c.type === "FeatureCollection") {
                        projectGeometry.push(c.features[0]);
                    }
                });

                const collection = {
                    type: "FeatureCollection",
                    features: projectGeometry,
                }
                map.getSource("isTiledInMapox").setData(collection);
            });
    }

    // clearLineFilter.addEventListener("click", () => {
    //     map.setFilter("route", null);
    //     map.setFilter("linefill", null);
    // });

    // enumerate ids of the layers
    //const toggleableLayerIds = ["mapbox-satellite", "NTS Unit Grid", "NTS Unit Labels", "NTS Block Grid", "NTS Block Labels", "bc-pipelines-all", "isTiledInMapox"];
    const toggleableLayerIds = ["mapbox-satellite"];
    const layersToColorize = ["all-wells", "well-licensee-labels", "facilities"];
    const enabledByDefault = ["bc-unit-labels", "bc-unit-grids", "NTS Unit Grid", "NTS Unit Labels", "NTS Block Grid", "NTS Block Labels"];

    // set up the corresponding toggle button for each layer
    for (var i = 0; i < toggleableLayerIds.length; i++) {
        var id = toggleableLayerIds[i];

        var link = document.createElement("a");
        link.href = "#";
        link.className = enabledByDefault.includes(id) ? "active" : "";
        link.textContent = id;

        link.onclick = function (e) {
            var clickedLayer = this.textContent;
            e.preventDefault();
            e.stopPropagation();

            var visibility = map.getLayoutProperty(clickedLayer, "visibility");
            // console.log('clickedLayer', clickedLayer, visibility);

            // toggle layer visibility by changing the layout object's visibility property
            if (visibility === "visible" || _.isNil(visibility)) {
                // HACK: visibility can be initially undefined
                map.setLayoutProperty(clickedLayer, "visibility", "none");
                this.className = "";
                if (id === "mapbox-satellite") {
                    layersToColorize.forEach((layer) => {
                        map.setPaintProperty(layer, "text-color", "#000");
                    });
                }
            } else {
                this.className = "active";
                map.setLayoutProperty(clickedLayer, "visibility", "visible");
                if (id === "mapbox-satellite") {
                    layersToColorize.forEach((layer) => {
                        map.setPaintProperty(layer, "text-color", "#fff");
                    });
                }
            }
        };

        var layers = document.getElementById("menu");
        layers.appendChild(link);
    }

    inputFilter.addEventListener("input", (e) => {
        const search = inputFilter.value;
        setFilter(search);
    });

    groupsInput.addEventListener("change", (e) => {
        const val = groups.value;
        filters.group = val;
        updateTable();

        //update projects
        projectsInput.style.display = "inline";
        projectsInput.length = 0; //clear prev data

        const projects = [
            ...new Set(arrayData.filter((i) => i.group === filters.group).map((i) => i["Project #"])),
        ].sort((a, b) => a - b);
        projects.unshift("all"); //this will select all elements
        projects.forEach((i) => {
            if (i === "") i = "empty";
            var option = document.createElement("option");
            option.text = i;
            option.value = i;
            projectsInput.appendChild(option);
        });
    });

    projectsInput.addEventListener("change", (e) => {
        console.log("projectsInput");
        const val = projectsInput.value;
        filters.project = val;

        inputFilter.value = projectsInput.value;
        setFilter(projectsInput.value);

        updateTable();
    });

    incompleteFilter.addEventListener("change", () => {
        const val = incomplete.checked;
        filters.incomplete = val;
        // console.log("incomplete val", val);
        updateTable();
    });

    corridorsFilter.addEventListener("change", () => {
        const val = corridors.checked;
        filters.corridors = val;
        console.log("corridors val", val);
        updateTable();
    });

    nextProjectButton.addEventListener("click", () => {
        console.log("nextProject");
        nextProject();
    });

    function nextProject() {
        // const projects = [...new Set(arrayData.filter(i => i.group === filters.group).map(i => i['Project #']))].sort((a, b) => a - b)

        /* const curr = projects.indexOf(filters.project)
        if (projects[curr + 1]) {
            filters.project = projects[curr + 1];
            projectsInput.querySelector('[value="' + filters.project + '"]').selected = true // update selector val
        } else {
            // goto next group
            console.warn('Switching to next group',);
        } */

        // find next empty project from this group
        let gr;
        if (filters.corridors) {
            gr = [
                ...new Set(
                    arrayData
                        .filter((i) => i.group === filters.group) // find all with current group
                        .filter((i) => i.completed === false) // find all uncompleted
                        .filter((i) => i.info["Corridor Exists"] === "TRUE") // find all with corridors
                        .map((i) => i["Project #"])
                ),
            ]; // get the list of project numbers
        } else {
            gr = [
                ...new Set(
                    arrayData
                        .filter((i) => i.group === filters.group) // find all with current group
                        .filter((i) => i.completed === false) // find all uncompleted
                        .map((i) => i["Project #"])
                ),
            ]; // get the list of project numbers
        }

        filters.project = gr.find((i) => +i > +filters.project);
        projectsInput.querySelector('[value="' + filters.project + '"]').selected = true; // update selector val
        inputFilter.value = filters.project;
        setFilter(filters.project);

        updateTable();
    }

    function updateTable() {
        const data = filterData();
        pagination.setTotalItems(data.length);
        pagination.reset();
        printPage(0, options.itemsPerPage, data);
    }

    function filterData() {
        const data = arrayData
            .filter((i) => {
                if (filters.search && filters.search !== "") {
                    return +i["Project #"] === +filters.search;
                }
                return i;
            })
            .filter((i) => {
                if (filters.group && filters.group !== "") {
                    return i["group"] === filters.group;
                }
                return i;
            })
            .filter((i) => {
                if (filters.incomplete) {
                    return i.completed === false;
                }
                return i;
            })
            .filter((i) => {
                if (filters.corridors) {
                    return i.info["Corridor Exists"] === "TRUE";
                }
                return i;
            })
            .filter((i) => {
                if (filters.project) {
                    if (filters.project === "all") {
                        return i;
                    }

                    return +i["Project #"] === +filters.project;
                }
                return i;
            });

        console.log("filters====>", filters);
        console.log("filtered data", data);
        return data;
    }

    function setFilter(filter) {
        inputFilter.value = filter;
        filters.search = +filter;

        if (filter !== "") {
            map.setFilter("route", ["==", ["to-number", ["get", "PROJECT_NU"]], +filter]);
            map.setFilter("linefill", ["==", ["to-number", ["get", "PROJECT_NU"]], +filter]);
        } else {
            map.setFilter("route", null);
            map.setFilter("linefill", null);
        }
        updateTable();
    }

    shortcut.add("Ctrl+S", function () {
        console.log("Saving");

        var modal = document.getElementById("myModal");
        if (modal.style.display === "block") {
            //modal is already opened
            var save = document.getElementById("save");
            save.click();
        } else {
            saveData(); //open modal
        }
    });


    const wkt = new Wkt.Wkt();
    document.addEventListener("click", (e) => {
        if (e.target.classList.contains("filter")) {
            const prId = e.target.getAttribute("project");
            setFilter(prId);
        }

        const target = e.target.closest("td.pipe");
        if (target !== null) {

            selectedId = target.getAttribute("lineid");

            const sq = arrayData.find(i => i['Pipeline ID'] === selectedId);
            if (sq) {
                const to = sq['Approximate From Geometry (JSON)'];
                const from = sq['Approximate To Geometry (JSON)'];
                const toJSON = wkt.read(to).toJson();
                const fromJSON = wkt.read(from).toJson();
                const collection = turf.featureCollection([
                    turf.feature(toJSON),
                    turf.feature(fromJSON)
                ]);
                map.getSource("squares").setData(collection);
                const combined = turf.combine(collection);
                const bounds = turf.bbox(combined);
                map.fitBounds(bounds, { padding: 100 });
            }

            getLine(selectedId)

        }
    });

    function getLine(id) {

        Draw.deleteAll();

        const query = apiUrl + "?pipe_pipeline_id=" + id;
        console.log("query", query);
        fetch(query)
            .then((response) => response.json())
            .then(pipeline => {

                console.log('pipeline', pipeline);
                if (pipeline.geometry) {
                    Draw.deleteAll();
                    Draw.add(pipeline.geometry);
                }
            })
    }

    let currentPipeline = null;

    function printPage(start, end, data) {
        console.log("printPage data", data);
        currentPage.length = 0;
        const queryData = data.slice(start, end).map((i) => {
            currentPage.push({
                number: i["Project #"],
                segment: i["Segment #"],
                done: false,
            });
            return [i["Project #"], i["Segment #"]];
        });

        console.log("queryData", queryData);

        const res = getlines(queryData);
        res.then((d) => {
            console.log("COMPLETED ELEMENTS", d);
            if (!d || d.length === 0) return;
            //compare data and find the number of processed pipes in DB

            const projectGeometry = [];

            d.forEach((i) => {
                //update main array with completed elements
                const { number, segment } = i;

                //arrayData.find(i=>+i['Project #'] === +number && +i['Segment #'] === +segment).completed = true;

                const id = `green_${number}_${segment}`;
                //console.log('id===>', id);

                const el = document.getElementById(id);
                if (el) {
                    //some elements returned by DB does not exist on this page
                    el.style.backgroundColor = "green";
                    const s = (currentPage.find((i) => i.number === +number && i.segment === +segment).done = true);
                    //console.log('s===>', s);
                    //console.log('s', number, segment);
                }

                projectGeometry.push(JSON.parse(i.geometry));
                map.getSource("projectGeometry").setData({
                    type: "FeatureCollection",
                    features: projectGeometry,
                });
            });

            console.log("projectGeometry", projectGeometry);
        });

        let table = '<table class="lines">';
        data.slice(start, end).forEach((i) => {
            // console.log('i',i);
            const id = `${i["Project #"]}_${i["Segment #"]}`;
            table += `<tr class="line" id="">
                        <td class="gotPipe"  id="green_${id}"></td>
                        <td class="pipe"
                            lineid="${i["Project #"]}"
                            segment="${i["Segment #"]}"
                            type="${i["Grid"]}"
                            coord1 = "${i["Long_1"]},${i["Lat_1"]}"
                            coord2 = "${i["Long_2"]},${i["Lat_2"]}"
                            from_loc = "${i.info["From"]}"
                            to_loc = "${i.info["To"]}"
                            >
                            <div> <b>${i["Project #"]}|#${i["Segment #"]}</b> / ${i["Product"]} / ${i.info["Outer Diam (mm)"]} mm </div>
                            <div>${i["Company"]}</div>
                            <div><b>${i["Status"]}</b> / ${i["Grid"]} | ${i.info["As Built Date"]}</div>
                            <div><b>Length(m): ${i["Length (m)"]}</b></div>
                            <div class="pipeLength" id="pipe_${id}"> </div>
                            <div><b>From</b>: ${i.info["From"]}</div>
                            <div><b>To</b>:${i.info["To"]}</div>
                        </td>
                        <td>
                            <button class="btn saveData" id="b_${id}" onclick="saveData(${i["Project #"]}, ${i["Segment #"]})" style="visibility:hidden;"><i class="fa fa-save"></i></button>
                        </td>
                    </tr>
                `;
        });
        table += "</table>";
        list.innerHTML = table;
    }

    function getlines(queryData) {
        console.log("queryData", queryData);

        return fetch(apiUrl, {
            method: "POST",
            headers: {
                "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
            },
            body: new URLSearchParams({
                query_lines: JSON.stringify(queryData),
            }),
        })
            .then((i) => i.json())
            .then((json) => {
                console.log("getlines response json", json);
                return json;
            })
            .catch(function (error) {
                console.error("Request failed", error);
            });
    }

    function saveData() {

        Draw.changeMode(Draw.modes.SIMPLE_SELECT);

        const pipses = Draw.getAll().features.length;
        if (pipses > 1) {
            alert("More than 1 line!")
            return;
        }

        openModal(saveDataToDB);

    }

    function saveDataToDB() {
        console.log("arguments", arguments);

        const { score, note, additionalData } = arguments[0];
        const { number, segment } = filters;



        console.log(score, note, number, segment);
        //get drawn data
        const collection = Draw.getAll();
        const feature = collection.features[0];

        if (!feature) {
            toast("Empty geometry!");
            console.warn("Empty geometry!");
            console.warn(collection);
            //return;
        } else {
            const length = turf.length(collection.features[0], { units: "meters" });
            feature.properties.length = length;
        }

        console.log("feature!!!!!!!!!!!!!!!!!!!!!", feature);
        console.log("collection!!!!!!!!!!!!!!!!!!!!!", collection);

        fetch(apiUrl, {
            method: "POST",
            headers: {
                "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
            },
            body: new URLSearchParams({
                score,
                note,
                insert_pipe: selectedId, //global
                pipe_segment_number: segment,
                pipe_geojson: JSON.stringify(collection),
                additional_pipe_ids: JSON.stringify(additionalData)
                //pipe_geojson: JSON.stringify(collection.features[collection.features.length - 1])//save last geometry object or line
            }),
        })
            .then((response) => {
                if (response.ok) {
                    console.log("the call works ok", response);

                    toast("Geometry saved");


                    //update color
                    const e = document.getElementById(`green_${selectedId}`)
                    e.style.backgroundColor = 'green'
                    e.setAttribute("done", "true");

                    calcColors(goToNext); //racalculate colors aftes saving data


                    //clear all prev lines 
                    Draw.deleteAll()
                    const collextion = turf.featureCollection([])
                    map.getSource("squares").setData(collection);
                }


            })
            .catch(function (error) {
                console.log("Request failed", error);
            });

        // getIsTiledInMapbox();//redraw the isTiledInMapbox() layer
    }

    function findFirstEmptyIndex(currentPage) {
        let next = 0;
        for (let index = 0; index < currentPage.length; index++) {
            const element = currentPage[index];
            if (!element.done) {
                next = index;
                break;
            }
        }
        return next;
    }

    function goToNext() {

        const index = arrayData.findIndex(s => s['Pipeline ID'] === selectedId);
        const next = arrayData.find((i, key) => i.done === false && key > index);
        document.querySelector(`td[lineid="${next['Pipeline ID']}"]`).click()

    }

    async function calcColors(callback) {
        // recalculate color and update map
        console.log('recalculate colors',);
        const query = apiUrl + "?all_pipes";
        await fetch(query)
            .then((i) => i.json())
            .then((json) => {
                allPipes = json; //global
            });
        const inDB = allPipes.map(i => i.number);

        arrayData.forEach(s => {
            if (inDB.includes(s['Pipeline ID'])) {
                s.done = true;
            } else {
                s.done = false;
            }
        })

        Array.from(document.getElementsByClassName("gotPipe")).map(i => {
            const id = i.id.split("_")[1]
            if (inDB.includes(id)) {
                i.parentElement.setAttribute("done", "true")
                i.style.backgroundColor = "green"
            } else {
                i.parentElement.setAttribute("done", "false")
            }
        })

        if (callback) {
            callback()
        }
    }

    function filterLinesById(id) {
        if (!map || !listJson || !listJson.features) return;
        console.log("filterLinesById", id);

        const line = listJson.features.find((i) => +i.properties.PROJECT_NU === +id);

        if (line) {
            console.log("line", line);
            const bbox = turf.bbox(line);
            map.fitBounds(bbox, { padding: 50 });
            map.setFilter("route", ["==", ["to-number", ["get", "PROJECT_NU"]], +id]);
            map.setFilter("linefill", ["==", ["to-number", ["get", "PROJECT_NU"]], +id]);
        }
    }

    function createSquare(center, radius) {
        const circele = turf.circle(center, radius, { steps: 64 });
        const bbox = turf.bbox(circele);
        const square = turf.bboxPolygon(bbox);
        return square;
    }

    function toast(text) {
        Toastify({
            text: text,
            duration: 1500,
            // destination: "https://github.com/apvarun/toastify-js",
            newWindow: true,
            close: true,
            gravity: "top", // `top` or `bottom`
            position: "center", // `left`, `center` or `right`
            backgroundColor: "linear-gradient(to right, #3887be, #2aa9bf)",
            stopOnFocus: true, // Prevents dismissing of toast on hover
            onClick: function () { }, // Callback after click
        }).showToast();
    }

    function openModal(callback) {
        // Get the modal
        var modal = document.getElementById("myModal");
        var save = document.getElementById("save");
        var score = document.getElementById("score");
        var scoreInput = document.getElementById("score");
        var noteInput = document.getElementById("note");
        var cancel = document.getElementById("cancel");
        var span = document.getElementsByClassName("close")[0];
        var saveAsDiv = document.getElementById("savelist")

        modal.style.display = "block";
        // When the user clicks on <span> (x), close the modal
        span.onclick = function () {
            modal.style.display = "none";
        };
        save.onclick = function () {

            //get additional data from SAVE AS DROPDOWN
            const additionalData = [];
            document.querySelectorAll(".additional_data:checked").forEach(i => {
                const segment = i.getAttribute("segment")
                const project = i.getAttribute("project")

                additionalData.push({
                    segment,
                    project
                })
            })
            console.log("Save");
            const score = scoreInput.value;
            const note = noteInput.value;
            if (callback) {
                callback({ score, note, filters, additionalData });
            }
            modal.style.display = "none";
        };
        cancel.onclick = function () {
            console.log("Cancel");
            modal.style.display = "none";
        };

    }
</script>

</html>